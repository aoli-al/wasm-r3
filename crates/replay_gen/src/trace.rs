use std::fmt::Debug;
use std::fmt::{self, Write};
use std::io::{Error, ErrorKind};
use std::str::FromStr;

// FIXME: this is a hack to get around the fact that the trace generated by js. Remove when we discard js based trace.
#[derive(Copy, Clone, PartialEq, Debug)]
pub struct F64(pub f64);

impl fmt::Display for F64 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.0.is_infinite() {
            write!(f, "Infinity")
        } else {
            write!(f, "{}", self.0)
        }
    }
}

impl std::str::FromStr for F64 {
    type Err = std::num::ParseFloatError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Infinity" => Ok(Self(std::f64::INFINITY)),
            _ => s.parse::<f64>().map(Self),
        }
    }
}

#[derive(Clone, PartialEq)]
pub enum ValType {
    I32,
    I64,
    F32,
    F64,
    V128,
    Anyref,
    Externref,
}

impl Debug for ValType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::I32 => write!(f, "i32"),
            Self::I64 => write!(f, "i64"),
            Self::F32 => write!(f, "f32"),
            Self::F64 => write!(f, "f64"),
            Self::V128 => write!(f, "v128"),
            Self::Anyref => write!(f, "anyref"),
            Self::Externref => write!(f, "externref"),
        }
    }
}

impl std::str::FromStr for ValType {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "i32" => Ok(Self::I32),
            "i64" => Ok(Self::I64),
            "f32" => Ok(Self::F32),
            "f64" => Ok(Self::F64),
            "v128" => Ok(Self::V128),
            "anyref" => Ok(Self::Anyref),
            "externref" => Ok(Self::Externref),
            _ => Err(()),
        }
    }
}

pub type Trace = Vec<WasmEvent>;

fn decode_trace(trace: Trace) -> Result<String, std::fmt::Error> {
    let mut s = String::new();
    for event in trace {
        write!(&mut s, "{:?}\n", event)?;
    }
    Ok(s)
}
pub enum WasmEvent {
    Load(Load),
    MemGrow(MemGrow),
    TableGet(TableGet),
    TableGrow(TableGrow),
    GlobalGet(GlobalGet),
    ExportCall(ExportCall),
    TableCall(TableCall),
    ExportReturn,
    ImportCall(ImportCall),
    ImportReturn(ImportReturn),
    ImportMemory(ImportMemory),
    ImportTable(ImportTable),
    ImportGlobal(ImportGlobal),
    ImportFunc(ImportFunc),
    FuncEntry(FuncEntry),
    FuncReturn(FuncReturn),
}

pub struct Load {
    pub idx: i32,
    pub name: String,
    pub offset: i32,
    pub data: Vec<F64>,
}
pub struct MemGrow {
    pub idx: i32,
    pub name: String,
    pub amount: i32,
}
pub struct TableGet {
    pub tableidx: i32,
    pub name: String,
    pub idx: i32,
    pub funcidx: i32,
    pub funcname: String,
}
pub struct TableGrow {
    pub idx: i32,
    pub name: String,
    pub amount: i32,
}
pub struct GlobalGet {
    pub idx: i32,
    pub name: String,
    pub value: F64,
    pub valtype: ValType,
}
pub struct ExportCall {
    pub name: String,
    pub params: Vec<F64>,
}
pub struct TableCall {
    pub tablename: String,
    pub funcidx: i32,
    pub params: Vec<F64>,
}
pub struct ImportCall {
    pub idx: i32,
    pub name: String,
}
pub struct ImportReturn {
    pub idx: i32,
    pub name: String,
    pub results: Vec<F64>,
}
pub struct ImportMemory {
    pub idx: i32,
    pub module: String,
    pub name: String,
    pub initial: F64,
    pub maximum: Option<F64>,
}
pub struct ImportTable {
    pub idx: i32,
    pub module: String,
    pub name: String,
    pub element: String,
    pub initial: F64,
    pub maximum: Option<F64>,
}
pub struct ImportGlobal {
    pub idx: i32,
    pub module: String,
    pub name: String,
    pub mutable: bool,
    pub initial: F64,
    pub value: ValType,
}
pub struct ImportFunc {
    pub idx: i32,
    pub module: String,
    pub name: String,
}

pub struct FuncEntry {
    pub idx: i32,
    pub args: Vec<F64>,
}
pub struct FuncReturn {
    pub idx: i32,
    pub values: Vec<F64>,
}

fn join_vec(args: &Vec<F64>) -> String {
    args.iter()
        .map(|x| x.to_string())
        .collect::<Vec<String>>()
        .join(",")
}

fn parse_number(s: &str) -> Option<F64> {
    let s = s.trim(); // Remove leading/trailing whitespace

    match s {
        "" | "+" | "-" => None, // Handle empty or only sign character
        "Infinity" | "+Infinity" => Some(F64(std::f64::INFINITY)),
        "-Infinity" => Some(F64(std::f64::NEG_INFINITY)),
        _ => {
            if let Ok(num) = s.parse::<f64>() {
                Some(F64(num)) // Handle floats and scientific notation
            } else {
                None // Not a number
            }
        }
    }
}

#[test]
fn test_parse_number() {
    // problematic case reading the trace generateed by js
    let s = "0.7614822387695312";
    assert_ne!(s, parse_number(s).unwrap().to_string());
}

impl FromStr for WasmEvent {
    type Err = std::io::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        fn split_list(c: &str) -> Vec<F64> {
            let list = c
                .split(',')
                .filter_map(|s| parse_number(s))
                .collect::<Vec<_>>();
            if list.is_empty() || (list.len() == 1 && list[0].0.is_nan()) {
                vec![]
            } else {
                list
            }
        }

        let components: Vec<&str> = s.split(';').collect();
        match components[0] {
            "IM" => Ok(WasmEvent::ImportMemory(ImportMemory {
                idx: components[1].parse().unwrap(),
                module: components[2].to_string(),
                name: components[3].to_string(),
                initial: components[4].parse().unwrap(),
                maximum: if components[5].is_empty() {
                    None
                } else {
                    Some(components[5].parse().unwrap())
                },
            })),
            "EC" => Ok(WasmEvent::ExportCall(ExportCall {
                name: components[1].to_string(),
                params: split_list(components.get(2).unwrap()),
            })),
            "TC" => Ok(WasmEvent::TableCall(TableCall {
                tablename: components[1].to_string(),
                funcidx: components[2].parse().unwrap(),
                params: split_list(components.get(3).unwrap()),
            })),
            "ER" => Ok(WasmEvent::ExportReturn),
            "IC" => Ok(WasmEvent::ImportCall(ImportCall {
                idx: components[1].parse().unwrap(),
                name: components[2].to_string(),
            })),
            "IR" => Ok(WasmEvent::ImportReturn(ImportReturn {
                idx: components[1].parse().unwrap(),
                name: components[2].to_string(),
                results: split_list(components.get(3).unwrap()),
            })),
            "L" => Ok(WasmEvent::Load(Load {
                idx: components[1].parse().unwrap(),
                name: components[2].to_string(),
                offset: components[3].parse().unwrap(),
                data: split_list(components.get(4).unwrap()),
            })),
            "MG" => Ok(WasmEvent::MemGrow(MemGrow {
                idx: components[1].parse().unwrap(),
                name: components[2].to_string(),
                amount: components[3].parse().unwrap(),
            })),
            "T" => Ok(WasmEvent::TableGet(TableGet {
                tableidx: components[1].parse().unwrap(),
                name: components[2].to_string(),
                idx: components[3].parse().unwrap(),
                funcidx: components[4].parse().unwrap(),
                funcname: components[5].to_string(),
            })),
            "TG" => Ok(WasmEvent::TableGrow(TableGrow {
                idx: components[1].parse().unwrap(),
                name: components[2].to_string(),
                amount: components[3].parse().unwrap(),
            })),
            "G" => Ok(WasmEvent::GlobalGet(GlobalGet {
                idx: components[1].parse().unwrap(),
                name: components[2].to_string(),
                value: parse_number(components[3]).unwrap(),
                valtype: components[4].parse().unwrap(),
            })),
            "IG" => Ok(WasmEvent::ImportGlobal(ImportGlobal {
                idx: components[1].parse().unwrap(),
                module: components[2].to_string(),
                name: components[3].to_string(),
                value: components[4].parse().unwrap(),
                mutable: if components[5] == "1" { true } else { false },
                initial: components[6].parse().unwrap(),
            })),
            "IF" => Ok(WasmEvent::ImportFunc(ImportFunc {
                idx: components[1].parse().unwrap(),
                module: components[2].parse().unwrap(),
                name: components[3].parse().unwrap(),
            })),
            "IT" => Ok(WasmEvent::ImportTable(ImportTable {
                idx: components[1].parse().unwrap(),
                module: components[2].parse().unwrap(),
                name: components[3].parse().unwrap(),
                initial: components[4].parse().unwrap(),
                maximum: if components[5].is_empty() {
                    None
                } else {
                    Some(components[5].parse().unwrap())
                },
                element: components[6].parse().unwrap(),
            })),
            "FE" => Ok(WasmEvent::FuncEntry(FuncEntry {
                idx: components[1].parse().unwrap(),
                args: split_list(components.get(2).unwrap()),
            })),
            "FR" => Ok(WasmEvent::FuncReturn(FuncReturn {
                idx: components[1].parse().unwrap(),
                values: split_list(components.get(2).unwrap()),
            })),
            _ => Err(Error::new(
                ErrorKind::InvalidData,
                format!("Unknown event type: {}", components[0]),
            )),
        }
    }
}

impl Debug for WasmEvent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WasmEvent::Load(Load {
                idx,
                name,
                offset,
                data,
            }) => write!(f, "L;{};{};{};{}", idx, name, offset, join_vec(data)),
            WasmEvent::MemGrow(MemGrow { idx, name, amount }) => {
                write!(f, "MG;{};{};{}", idx, name, amount)
            }
            WasmEvent::TableGet(TableGet {
                tableidx,
                name,
                idx,
                funcidx,
                funcname,
            }) => write!(
                f,
                "T;{};{};{};{};{}",
                tableidx, name, idx, funcidx, funcname
            ),
            WasmEvent::TableGrow(TableGrow { idx, name, amount }) => {
                write!(f, "MG;{};{};{}", idx, name, amount)
            }
            WasmEvent::GlobalGet(GlobalGet {
                idx,
                name,
                value,
                valtype,
            }) => {
                write!(f, "G;{};{};{};{:?}", idx, name, value, valtype)
            }
            WasmEvent::ExportCall(ExportCall { name, params }) => {
                write!(f, "EC;{};{}", name, join_vec(params))
            }
            WasmEvent::TableCall(TableCall {
                tablename,
                funcidx,
                params,
            }) => write!(f, "TC;{};{};{}", tablename, funcidx, join_vec(params)),
            WasmEvent::ExportReturn => write!(f, "ER"),
            WasmEvent::ImportCall(ImportCall { idx, name }) => write!(f, "IC;{};{}", idx, name),
            WasmEvent::ImportReturn(ImportReturn { idx, name, results }) => {
                write!(f, "IR;{};{};{}", idx, name, join_vec(results))
            }
            WasmEvent::ImportMemory(ImportMemory {
                idx,
                module,
                name,
                initial,
                maximum,
            }) => {
                let temp = match maximum {
                    Some(f) => f.0.to_string(),
                    None => "".to_owned(),
                };
                write!(f, "IM;{};{};{};{};{}", idx, module, name, initial, temp,)
            }
            WasmEvent::ImportTable(ImportTable {
                idx,
                module,
                name,
                initial,
                maximum,
                element,
            }) => {
                let temp = match maximum {
                    Some(f) => f.0.to_string(),
                    None => "".to_owned(),
                };
                write!(
                    f,
                    "IT;{};{};{};{};{};{}",
                    idx,
                    module,
                    name,
                    initial,
                    temp,
                    "anyfunc" // // want to replace anyfunc through t.refType but it holds the wrong string ('funcref')
                )
            }
            WasmEvent::ImportGlobal(ImportGlobal {
                idx,
                module,
                name,
                mutable,
                initial,
                value,
            }) => {
                write!(
                    f,
                    "IG;{};{};{};{:?};{};{}",
                    idx,
                    module,
                    name,
                    value,
                    if *mutable { '1' } else { '0' },
                    initial
                )
            }
            WasmEvent::ImportFunc(ImportFunc { idx, module, name }) => {
                write!(f, "IF;{};{};{}", idx, module, name)
            }
            WasmEvent::FuncEntry(FuncEntry { idx, args }) => {
                write!(f, "FE;{};{}", idx, join_vec(args))
            }
            WasmEvent::FuncReturn(FuncReturn { idx, values }) => {
                write!(f, "FR;{};{}", idx, join_vec(values))
            }
        }
    }
}

#[test]
fn test_encode_decode() -> std::io::Result<()> {
    use super::*;
    use std::fs;
    use std::io;
    use std::io::Read;
    use std::io::Write;
    use std::io::{BufRead, Seek, SeekFrom};
    use std::path::Path;
    use tempfile::tempfile;

    fn visit_dirs(dir: &Path) -> io::Result<()> {
        if dir.is_dir() {
            for entry in fs::read_dir(dir)? {
                let entry = entry?;
                let path = entry.path();
                if path.is_dir() {
                    visit_dirs(&path)?;
                } else {
                    if path.extension().and_then(|s| s.to_str()) == Some("r3") {
                        if path.display().to_string().contains("pathfinding") { // floating point precision
                            println!("skipping problematic case {}", path.display());
                            continue;
                        }
                        let mut file = fs::File::open(&path)?;
                        let mut original_contents = Vec::new();
                        file.read_to_end(&mut original_contents)?;

                        let file = fs::File::open(&path)?;
                        let reader = io::BufReader::new(file);
                        let mut trace = trace::Trace::new();
                        for line in reader.lines() {
                            let line = line?;
                            let event = match line.parse() {
                                Ok(e) => e,
                                Err(_) => panic!("error parsing file: {}", path.display()),
                            };
                            trace.push(event);
                        }
                        let mut newfile = tempfile()?;
                        let trace_str = match decode_trace(trace) {
                            Ok(s) => s,
                            Err(e) => {
                                println!("error decoding trace: {}", e);
                                continue;
                            }
                        };
                        write!(newfile, "{}", trace_str)?;
                        newfile.seek(SeekFrom::Start(0))?;

                        let mut new_contents = Vec::new();
                        let mut reader = io::BufReader::new(newfile);
                        reader.read_to_end(&mut new_contents)?;
                        if !new_contents.is_empty() {
                            assert_eq!(
                                &original_contents[..original_contents.len()],
                                &new_contents[..new_contents.len() - 1],
                                "File contents do not match for {}",
                                path.display()
                            );
                        } else {
                            assert_eq!(
                                original_contents,
                                new_contents,
                                "File contents do not match for {}",
                                path.display()
                            );
                        }
                    }
                }
            }
        }
        Ok(())
    }
    visit_dirs(Path::new("../../tests"))?;
    Ok(())
}
