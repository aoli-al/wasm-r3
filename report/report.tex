%-------------------------------------------------------------------------------------------------
%
%  Skeleton for bachelor and master thesis reports at the Software Lab
%-----------------------------------------------------------------------------------------
%
% USAGE:      compile with PDFLaTeX
%
% HISTORY:    - written by Sascha A. Stoeter <stoeter@iris.ethz.ch>, www.stoeter.com, 02.06.2004
%             - modified by Martin Probst, 18.08.2004
%             - extended and adapted for use at LST by Oliver Trachsel, 2007-08-21
%             - modified for use at Software Lab by Michael Pradel, Nov 2014
%             - modified for use at U Stuttgart by Michael Pradel, Sep 2020
%-------------------------------------------------------------------------------------------------
\documentclass[11pt,a4paper]{book}
\usepackage{solareport}

% -------------------------------------------------------------------------------------------------
% Add needed packages. Some generally useful packages are listed for
% your convenience.
% -------------------------------------------------------------------------------------------------
\usepackage{subfigure}                          % enable the use of subfigures
\usepackage[thickspace,thinqspace]{SIunits}     %
\usepackage[plainpages=false,pdfpagelabels]{hyperref}    % enable hyperlinks in pdf/ps Docs
\usepackage{listings}                           % to embed source code

% -------------------------------------------------------------------------------------------------
% Select type of thesis
% -------------------------------------------------------------------------------------------------
%\def\thesistype{Bachelor}
\def\thesistype{Master}

% -------------------------------------------------------------------------------------------------
% Set names
% -------------------------------------------------------------------------------------------------
\def\thesisauthor{John Doe}
\def\thesisadvisor{} % leave empty if directly advised by Michael Pradel
\def\studyprogram{Computer Science} % e.g., Computer Science or INFOTECH

% -------------------------------------------------------------------------------------------------
% Set dates
% -------------------------------------------------------------------------------------------------
\def\thesisstartdate{November 1, 2020} 
\def\thesisenddate{April 30, 2021} 

% -------------------------------------------------------------------------------------------------
% Beginning of the main document body
% -------------------------------------------------------------------------------------------------
\begin{document}

% -------------------------------------------------------------------------------------------------
% Front matter with title page, table of contents, and abstracts 
% -------------------------------------------------------------------------------------------------
\frontmatter

% Title page: set title
\thesistitlepage{Thesis Title}

% Abstract must not be longer than one page per language. English and
% German abstracts are mandatory.
\chapter*{Abstract}
Short summary of thesis.

\chapter*{Zusammenfassung}
Kurzfassung der Arbeit.

% Table of contents
\tableofcontents

% -------------------------------------------------------------------------------------------------
% Main document body
% -------------------------------------------------------------------------------------------------
\mainmatter
\chapter{Introduction}
\label{s:Introduction}
Explain scope and structure of report.

\chapter{Background}
\section{WebAssembly}
\section{Record and Replay}
Software typically contains nondeterministic or nonpure behavior. We call
behavior nonpure when the execution and output of a particular program
depends on state and events that are independent of the running process.
From an application perspective nonpurity expresses itself as nondeterminism
for which reason we will use this term from now on for both types of behavior.
This basic property signifies that the execution of the same program might
yield different results for seperate runs. There are several applications where
this trait leads to shortcumings and restrictions. Consider for example
a bug that only appears with a certain probability in a nondeterministic
fashion. In order to eliminate this bug one must locate it first by narrowing
down to the possible locations it may appear. This process is significantly
complicated if a developer is not able to faithfully reproduce the bug and
instead relies on chance in order to observe it. Such problems motivated
a category of techniques which try to record and replay the execution of
a program to execute it deterministically with arbitrary repetitions.  
Record and replay techniques have been extensively studied in the past,
mostly for debugging purposes \cite{203227, Burg2013_InteractiveReplayWeb} and security analysis \cite{10.1145/844128.844148}. However this is not the only scenario in
which such approaches could be applied in order to resolve a problem.
The work of Richards et al. \cite{Richards2011-JavascripBenchmarks}
represents one of the rare exceptions in that record and replay techniques
are used for a different objective, namely
the creation of javascript benchmarks, derived from real world browser
applications. Replay based debuggers have been surveyed and categorised
by Dionne et al. \cite{Dionne1996-TaxonomyDebuggers} and Cornelis et al
\cite{Cornelis2003-TaxonomyReplay}. In the following chapters we use especially
the taxonomy of the latter to describe the underlying concepts and constraints
of replay systems.

All record and replay approaches rely on a trace which collects input and
outut values during the initial runtime of a specific program and provides
the necessary informations during replay in order to repeat the original
execution. On a lowest level programs can be viewed as streams of instructions
each of which consumes input and produces output. In order to produce a
faithful replay of such a program a naive approach would trace the input and
output of each instruction and provide these values to the same instructions
during replay. This \textit{content-based} approach has the advantage that a replay
may be started and stopped at any program point while always preserving the
original semantics. Despite this feature this approach is not feasable in
practice since tracing of all inputs and outputs of each instruction would
result in enourmus log sizes. Another approach is based on the idea captures
the initial state of the recording execution as complete as possible and rerun
the program based from that starting point. As the program leaves its initial
path during reexecuting due to nondeterminism, the process will be nudged to
the desired path through information that was additionally captured during
the record phase. This approach is called \textit{ordering-based}.
While implementable in practice this technique has the
significant disadvantage over \textit{content-based} approaches in that the replay
can only be started at the initial state which was captured during the first
execution. Abstracting from the instruction level, record and replay can also
be applied to more high level programs using more procedural languages instead
of machine instructions.

\subsection{Environment and Application}

Since CPUs are deterministic by nature, nondeterminism gets introduced to a
program by its surrounding. Interrupts like commands by peripheral input
devices or dedicated input instructions that demand information from the
surrounding system may cause the program to diverge from its usual path.
More formally we can describe the execution of an application through the
interaction between the deterministic application $A$ itself and the surrounding
environment $E$. In $A$'s perspective $E$ appears like a blackbox that
provides unpredictable values at unpredictable timings to which $A$ reacts
in a well defined manner. Specifically there are two types of interactions
possible. 1. $A$ may call $E$ in order to receive information that it can
not compute by itself and 2. $E$ might send signals or interupts to $A$
whose parameters can be arbitray. As example we can concretize this concept
by choosing $A$ to be a user space application and $E$ an operating system.
The application will request certain services from the operating system like
reading a file from the filesystem via its system call interface and retrieve
certain information about the outcome of these actions to which it reacts
accordingly. Similarily the operating system can send interrupts to the
application when the user uses the keyboard or mouse to issue certain commands
which also get handled by the application. In order to create a faithful
replay for the execution of $A$ one must record the full information exchange
between $A$ and $E$ that triggers certain behaviors in $A$. This information
can later be used to modify $E$ in a way to behave deterministically at
every reexecution of the program.

The nature of $E$ is such that
it is devided into layers. Each layer communicates via interfaces with the
layer directly above and below it. We call the highest level layer wich
provides an interface to $A$ \textit{first order environment}, the layer
directly below it \textit{second order environment}, and so on. To make this
more clear we again consider the above example. Previousely we have been
representing $E$ through the operating system. In fact the operating system
which represents the \textit{first order environment} runs itself on the
hardware with which it communicates via the instruction set architecture.
As another example we can consider a javascript application which runs
inside a web browser. The \textit{first order environment} here is the
browser itself or the virtual machine that powers the execution of the
application code which itself runs on the operating system, which again
runs on bare hardware.
% Explain the different strategies to modify the host environment
% Modifying
% Proxying
% Replacing
% Ignoring (Bake environment responses into A)

\subsection{Collecting runtime information}

To create a faithull replay of a program execution one must record all information
exchanged between the application and the environement. The information typically
gets collected in a trace which contains an entry for each relevant event that
happens during program execution and its
asossiated values. The system can then use this Data during replay in order to 
provide the same parameters to $A$ as they where observed during record. Traces of
this kind can grow to large sizes which motivates its optimisation and compression
in order to keep the memory usage on a reasonable level.

To collect traces one must measure certain attributes of the program during runtime.
In other words we require a method which is able to observe and safe the for replay
relevant events. This goal can be archived in two ways. Medicine destinguishes
between measuring instruments that look inside a patient vs those that do not.
Similarily we can decide between instrumentation on the source code level vs
instrumentation inside of the environment. Some articles call these different
approaches \textit{invasive} and \textit{non-invasive} \cite{janes2023open}, while
others call them \textit{intrusive} and \textit{non-intrusive} respecively \cite{Flexible Non-intrusive Dynamic Instrumentation for WebAssembly}.
In the following we will stick to the latter terminology. To instrument an application 
intrusively an instrumenter adds additional instructions to its source or byte code
which observes and transferes the desired information without altering the progams
semantics. % Now describe the advantages of intrusive
% Nonintusive


\chapter{Approach}
\section{Record}
\section{Replay}

\chapter{Implementation}

\chapter{Evaluation}

\chapter{Conclusion}

\chapter{Great Work}
\label{s:GreatWork}

This and the following chapters detail the original work.

\chapter{Examples}
\label{s:Examples}

This chapter provides some additional hints and examples for the
layout and style of the thesis. It is worthwhile to look at the source
file \verb|Examples.tex| for this appendix to understand how it was
created.

\section{Tables}

Tables are left justified and the caption appears on top as seen in
Table~\ref{t:Translations}.

\begin{table}[ht]
\centering
\begin{tabular}{ll}
\hline
\textbf{English} & \textbf{German}\\
\hline
cell phone       & Handy\\
Diet Coke        & Coca Cola light\\
\hline
\end{tabular}
\caption[Translations]{\label{t:Translations}Translations.}
\end{table}

\section{Figures}

Figure~\ref{f:SOLAlogo} shows a simple figure with a single picture
and Figure~\ref{f:SubfigureExample} shows a more complex figure
containing subfigures.

\begin{figure}[ht]
\centering
\includegraphics[width=.6\linewidth]{figures/SOLALogo}
\caption[SOLA logo]{\label{f:SOLAlogo}SOLA logo.}
\end{figure}

\begin{figure}[ht]
\centering
\subfigure[UStuttLogo]{\includegraphics[height=12mm]{figures/UStuttLogo}}\quad
\subfigure[SOLALogo]{\includegraphics[height=12mm]{figures/SOLALogo}}
\caption[Subfigure example]{\label{f:SubfigureExample}Two pictures as
  part of a single figure through the magic of the subfigure package.}
\end{figure}

\section{Units}

The SIUnits package provides nice spacing for units as demonstrated in
Table~\ref{t:SIUnits}. Use of the package also makes it easy to change
the style or even the unit text in the future.

\begin{table}[ht]
\centering
\begin{tabular}{ll}
\hline
\textbf{Output}   & \textbf{Command}\\
\hline
42m               & \verb|42m|\\
\unit{42}{\metre} & \verb|\unit{42}{\metre}|\\
42 m              & \verb|42 m|\\
\hline
\end{tabular}
\caption[Spacing for units]{\label{t:SIUnits}Spacing for units.}
\end{table}

\section{Source code}

The listings package provides tools to typeset source code
listings. It supports many programming languages and provides a lot of
formatting options.

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt}
\lstset{basicstyle=\ttfamily}
\lstset{frame=tb}

\begin{lstlisting}[float,caption=Example usage of the listing package,label=l:javaClass,language=Java]
class S {
   int f1 = 42;
   public S(int x) {
          f1 = x;
   }
}
\end{lstlisting}

Listing \ref{l:javaClass} shows an example listing. Code snippets can
also be inserted in normal text:
\verb$\lstinline|int f1 = 42;|$ gives \lstinline$int f1 = 42;$

\section{Miscellany}

\begin{description}

\item[Capitalization.] When referring to a named table (such as in the
  previous section), the word \emph{table} is capitalized. The same is
  true for figures, chapters and sections.

\item[Bibliography.] Use \verb|bibtex| to make your life easier and to
  produce consistently formatted entries.

\item[Contractions.] Avoid contractions. For instance, use ``do not''
  rather than ``don't.''

\item[Style guide.] A classic reference book on writing style is
  Strunk's \emph{The Elements of Style} \cite{Strunk-ElementsOfStyle}.

\end{description}

% -------------------------------------------------------------------------------------------------
% Appendices (if needed)
% -------------------------------------------------------------------------------------------------
\appendix
\chapter{Extra Stuff}
\label{s:ExtraStuff}

Additional material such as long mathematical derivations.

% -------------------------------------------------------------------------------------------------
% Bibliography
% -------------------------------------------------------------------------------------------------
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{report}

\input{legal_issues}

\end{document}
